package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/phaynes/markdown-processing/markdown-proofer/internal/config"
	"github.com/phaynes/markdown-processing/markdown-proofer/internal/proofing"
)

const testFileName = "test_file.md"
const testContent = `# Test File

This is a test file for mdp.
It contains some text that will be proofed.
There might be some misspellings or grammatical errors.`

func setupTestRepo(t *testing.T) (string, func()) {
	tempDir, err := ioutil.TempDir("", "mdp-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}

	cleanup := func() {
		os.RemoveAll(tempDir)
	}

	if err := os.Chdir(tempDir); err != nil {
		cleanup()
		t.Fatalf("Failed to change to temp directory: %v", err)
	}

	runCmd(t, "git", "init")
	writeFile(t, testFileName, testContent)
	runCmd(t, "git", "add", testFileName)
	runCmd(t, "git", "commit", "-m", "Initial commit")

	return tempDir, cleanup
}

func runCmd(t *testing.T, name string, args ...string) {
	cmd := exec.Command(name, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("Command '%s %s' failed: %v\nOutput: %s", name, strings.Join(args, " "), err, output)
	}
}

func writeFile(t *testing.T, filename, content string) {
	err := ioutil.WriteFile(filename, []byte(content), 0644)
	if err != nil {
		t.Fatalf("Failed to write file %s: %v", filename, err)
	}
}

func readFile(t *testing.T, filename string) string {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		t.Fatalf("Failed to read file %s: %v", filename, err)
	}
	return string(content)
}

func TestStandardProofing(t *testing.T) {
	tempDir, cleanup := setupTestRepo(t)
	defer cleanup()

	appConfig := &config.AppConfig{
		InputFile:    testFileName,
		ProofingType: "standard",
		Mode:         "proof",
	}

	stages, err := proofing.NewProofingStages(appConfig)
	if err != nil {
		t.Fatalf("Failed to create proofing stages: %v", err)
	}

	if err := runProofingWorkflow(stages, appConfig); err != nil {
		t.Fatalf("Standard proofing failed: %v", err)
	}

	// Check if the file was modified
	modifiedContent := readFile(t, testFileName)
	if modifiedContent == testContent {
		t.Errorf("File content was not modified in standard proofing")
	}
}

func TestGitFullProofing(t *testing.T) {
	tempDir, cleanup := setupTestRepo(t)
	defer cleanup()

	appConfig := &config.AppConfig{
		InputFile:    testFileName,
		ProofingType: "git_full",
		Mode:         "proof",
		AIConfig:     &config.AIConfig{UseGit: true},
	}

	stages, err := proofing.NewProofingStages(appConfig)
	if err != nil {
		t.Fatalf("Failed to create proofing stages: %v", err)
	}

	if err := runProofingWorkflow(stages, appConfig); err != nil {
		t.Fatalf("Git full proofing failed: %v", err)
	}

	// Check if a new commit was created
	runCmd(t, "git", "log", "-1", "--pretty=%B")

	// Check if the file was modified
	modifiedContent := readFile(t, testFileName)
	if modifiedContent == testContent {
		t.Errorf("File content was not modified in git full proofing")
	}
}

func TestGitDiffProofing(t *testing.T) {
	tempDir, cleanup := setupTestRepo(t)
	defer cleanup()

	// Make a change to the file
	modifiedContent := testContent + "\nThis is a new line with a misspelling."
	writeFile(t, testFileName, modifiedContent)

	appConfig := &config.AppConfig{
		InputFile:    testFileName,
		ProofingType: "git_diff",
		Mode:         "proof",
		AIConfig:     &config.AIConfig{UseGit: true, ProofGitDiff: true},
	}

	stages, err := proofing.NewProofingStages(appConfig)
	if err != nil {
		t.Fatalf("Failed to create proofing stages: %v", err)
	}

	if err := runProofingWorkflow(stages, appConfig); err != nil {
		t.Fatalf("Git diff proofing failed: %v", err)
	}

	// Check if only the new line was modified
	finalContent := readFile(t, testFileName)
	if !strings.Contains(finalContent, "This is a new line with a") || finalContent == modifiedContent {
		t.Errorf("Git diff proofing did not modify only the new line")
	}
}

func TestLineRangeProofing(t *testing.T) {
	tempDir, cleanup := setupTestRepo(t)
	defer cleanup()

	appConfig := &config.AppConfig{
		InputFile:    testFileName,
		ProofingType: "line_range",
		Mode:         "proof",
		LineRange:    "2-3",
	}

	stages, err := proofing.NewProofingStages(appConfig)
	if err != nil {
		t.Fatalf("Failed to create proofing stages: %v", err)
	}

	if err := runProofingWorkflow(stages, appConfig); err != nil {
		t.Fatalf("Line range proofing failed: %v", err)
	}

	// Check if only lines 2-3 were modified
	modifiedContent := readFile(t, testFileName)
	lines := strings.Split(modifiedContent, "\n")
	if lines[0] != "# Test File" || lines[len(lines)-1] != "There might be some misspellings or grammatical errors." {
		t.Errorf("Line range proofing modified lines outside the specified range")
	}
}

func runProofingWorkflow(stages proofing.ProofingStages, appConfig *config.AppConfig) error {
	if err := stages.Initialize(); err != nil {
		return fmt.Errorf("initialization failed: %v", err)
	}

	content, err := stages.PrepareContent()
	if err != nil {
		return fmt.Errorf("content preparation failed: %v", err)
	}

	proofedContent, err := stages.ExecuteProofing(content, "Test prompt")
	if err != nil {
		return fmt.Errorf("proofing execution failed: %v", err)
	}

	if err := stages.HandleOutput(proofedContent); err != nil {
		return fmt.Errorf("output handling failed: %v", err)
	}

	if err := stages.Finalize(); err != nil {
		return fmt.Errorf("finalization failed: %v", err)
	}

	return nil
}
